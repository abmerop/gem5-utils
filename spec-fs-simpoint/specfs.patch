# HG changeset patch
# Parent 5125a461f509541aeb68769c209d326f0ae216b7

diff -r 5125a461f509 configs/spec2006/nehalem.cfg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/spec2006/nehalem.cfg	Tue Jun 24 09:50:24 2014 -0400
@@ -0,0 +1,49 @@
+[cpu]
+type = nehalem
+
+[icache]
+hit_latency = 1
+response_latency = 1
+mshrs = 4
+tgts_per_mshr = 8
+size = 32kB
+assoc = 2
+is_top_level = true
+prefetch_on_access = true
+prefetcher = TaggedPrefetcher(degree = 2, latency = 1)
+
+[dcache]
+hit_latency = 3
+response_latency = 2
+mshrs = 16
+tgts_per_mshr = 8
+size = 32kB
+assoc = 4
+write_buffers = 16
+is_top_level = true
+prefetch_on_access = true
+prefetcher = StridePrefetcher(degree = 2, latency = 1)
+
+[l2]
+# 8 additional cycles on top of L1 miss
+hit_latency = 6
+response_latency = 2
+mshrs = 16
+tgts_per_mshr = 8
+size = 256kB
+assoc = 8
+write_buffers = 8
+prefetch_on_access = true
+prefetcher = StridePrefetcher(degree = 4, latency = 1)
+
+[l3]
+# 24 additional cycles on top of l2 miss
+hit_latency = 14
+response_latency = 10
+mshrs = 16
+tgts_per_mshr = 8
+size = 4MB
+assoc = 16
+write_buffers = 8
+prefetch_on_access = true
+prefetcher = StridePrefetcher(degree = 8, latency = 1)
diff -r 5125a461f509 configs/spec2006/pyterm.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/spec2006/pyterm.py	Tue Jun 24 09:50:24 2014 -0400
@@ -0,0 +1,101 @@
+#!/usr/bin/python
+
+#############################################################################################
+#
+# This module is able to run commands in gem5's FS mode. Your rcS script must start bash
+# at the end (/bin/bash) or no rcS should be provided since the default rcS file in
+# /etc/init.d/rcS will start bash.
+#
+#############################################################################################
+#
+# Start pyterm as follows:
+#
+# (term, inpipe) = pyterm.pyterm([port])
+#
+#
+# Run commands like this:
+#
+# inpipe.send("ls -l\n")
+#
+#
+# Clean up after yourself:
+#
+# close_pyterm(term, inpipe)
+#
+#############################################################################################
+#
+# Full example:
+#
+#
+# import pyterm
+#
+# (term, inpipe) = pyterm.pyterm(3456)
+#
+# exit_event = m5.simulate()
+# exit_cause = exit_event.getCause()
+#
+# while exit_cause == "myexitevent":
+#     inpipe.send("ls -l\n")
+#
+#     exit_event = m5.simulate()
+#     exit_cause = exit_event.getCause()
+#
+# close_pyterm(term, inpipe)
+#
+#############################################################################################
+import multiprocessing
+import socket
+import select
+import sys
+
+# Polling terminal process ... should be the most efficient way to do this.
+def TerminalProcess(pipe, port):
+    inpipe, outpipe = pipe
+    inpipe.close()
+
+    sock = socket.create_connection(("127.0.0.1", port))
+
+    sock.settimeout(10)
+
+    epoll = select.epoll()
+    epoll.register(sock.fileno(), select.EPOLLIN)
+    epoll.register(outpipe.fileno(), select.EPOLLIN)
+
+    should_exit = False
+
+    while not should_exit:
+        events = epoll.poll(1)
+        for fileno, event in events:
+            if fileno == sock.fileno():
+                sys.stdout.write(sock.recv(65536))
+            elif fileno == outpipe.fileno():
+                try:
+                    cmd = outpipe.recv()
+                    sock.send(cmd)
+                except EOFError:
+                    should_exit = True
+                    break
+
+    epoll.unregister(sock.fileno())
+    epoll.unregister(outpipe.fileno())
+    epoll.close()
+    outpipe.close()
+    sock.close()
+
+# Returns the term and input pipe.
+# term should be exited via .join() when exiting gem5
+# input pipe can be used to send data to gem5
+def pyterm(port=3456):
+    print "Trying to connect pyterm to port %d" % port
+    (inpipe, outpipe) = multiprocessing.Pipe()
+    term = multiprocessing.Process(target=TerminalProcess, args=((inpipe,outpipe),port,))
+    term.start()
+    outpipe.close()
+
+    return (term, inpipe)
+
+# Closes the input pipe and exits the child process
+def close_pyterm(term, inpipe):
+    inpipe.close()
+    term.join()
+
diff -r 5125a461f509 configs/spec2006/simpoint_fs.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/spec2006/simpoint_fs.py	Tue Jun 24 09:50:24 2014 -0400
@@ -0,0 +1,552 @@
+# Copyright (c) 2014, The Microsystem Design Laboratory (MDL)
+# Department of Computer Science and Engineering, The Pennsylvania State University
+# All rights reserved.
+#
+# The license below extends only to copyright in the software and shall
+# not be construed as granting a license to any other intellectual
+# property including but not limited to intellectual property relating
+# to a hardware implementation of the functionality of the software
+# licensed hereunder.  You may use the software subject to the license
+# terms below provided that you ensure that this notice is replicated
+# unmodified and in its entirety in all distributions of the software,
+# modified or unmodified, in source code or in binary form.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Matt Poremba
+
+import optparse
+import sys
+import ConfigParser
+import operator
+
+import m5
+from m5.defines import buildEnv
+from m5.objects import *
+from m5.util import addToPath, fatal
+
+addToPath('../common')
+
+from Nehalem import *
+from FSConfig import *
+from SysPaths import *
+import Simulation
+import MemConfig
+from Caches import *
+import spec_fs as spec_fs
+import pyterm
+import os
+import errno
+
+def mkdir_p(path):
+    try:
+        os.makedirs(path)
+    except OSError as exc: # Python >2.5
+        if exc.errno == errno.EEXIST and os.path.isdir(path):
+            pass
+        else:
+            raise
+
+parser = optparse.OptionParser()
+
+# Cache/CPU config options
+parser.add_option("--cfg", action="store", type="string", dest="cfg",
+                  help="The system config file to use.")
+parser.add_option("-n", "--num-cpus", type="int", default=1)
+
+# Run options
+parser.add_option("--simpoint-mode", type="choice", choices=["init", "checkpoint", "simulate", "check_affinity", "fastfwd"],
+                  default="init")
+parser.add_option("--checkpoint-dir", action="store", type="string",
+                  default=None, dest="checkpoint_dir",
+                  help="Directory containing simpoint checkpoints")
+parser.add_option("--init-checkpoint-dir", action="store", type="string",
+                  default=None, dest="init_checkpoint_dir",
+                  help="Directory containing checkpoint after system boot")
+parser.add_option("--benchmark", action="store", type="string", dest="benchmark",
+                  help="Name of benchmarks to run, separated by ':'")
+parser.add_option("-I", "--max-insts", type="int", default=0,
+                  help="Maximum number of instructions to simulate (simulate mode)")
+parser.add_option(      "--private-l2", action="store_true", help="Use one L2 per CPU")
+
+# Memory options
+parser.add_option("--nvmain-config", type="string", default="", help="NVMain configuration file to use.")
+parser.add_option("--nvmain-warmup", action="store_true", help="Warmup memory level caches in NVMain in atomic mode.")
+parser.add_option("--mem-size", action="store", type="string", default="2GB",
+                  help="Specify the physical memory size (single memory)")
+parser.add_option("--mem-type", type="choice", default="simple_mem",
+                  choices=MemConfig.mem_names(),
+                  help = "type of memory to use")
+parser.add_option("--mem-channels", type="int", default=1, # Not used for NVMain
+                  help = "number of memory channels")
+
+# Clock timings
+parser.add_option("--sys-clock", action="store", type="string",
+                  default='1GHz',
+                  help = """Top-level clock for blocks running at system
+                  speed""")
+parser.add_option("--cpu-clock", action="store", type="string",
+                  default='2GHz',
+                  help="Clock for blocks running at CPU speed")
+parser.add_option("--sys-voltage", action="store", type="string",
+                  default='1.0V',
+                  help="Top-level voltage for blocks running at system power supply")
+# FS Options
+parser.add_option("--kernel", action="store", type="string")
+parser.add_option("--disk-image", action="store", type="string", default=None,
+                  help="Path to the disk image to use.")
+parser.add_option("--init-param", action="store", type="int", default=0,
+                  help="""Parameter available in simulation with m5
+                          initparam""")
+parser.add_option("--script", action="store", type="string")
+parser.add_option("--isolated-cpus", type="string", help="Comma delimited list of CPUs which should be isolated")
+
+# Add NVMain override options
+argnum = 1
+for arg in sys.argv:
+    if arg[:9] == "--nvmain-" and arg != '--nvmain-config' and arg != '--nvmain-warmup':
+        parser.add_option(arg, type="string", default="NULL", help="Set NVMain configuration value for PARAM")
+    argnum = argnum + 1
+
+(options, args) = parser.parse_args()
+
+# Sanity checks
+if args:
+    print "Error: script doesn't take any positional arguments"
+    sys.exit(1)
+
+if options.cfg == None:
+    print "Error: no system config."
+    sys.exit(1)
+
+if options.simpoint_mode == "init" and options.init_checkpoint_dir == None:
+    print "Error: Need --init-checkpoint-dir for init mode."
+    sys.exit(1)
+elif options.simpoint_mode == "fastfwd" and options.init_checkpoint_dir == None:
+    print "Error: Need --init-checkpoint-dir for fastfwd mode."
+    sys.exit(1)
+elif options.simpoint_mode == "checkpoint":
+    if options.init_checkpoint_dir == None or options.checkpoint_dir == None:
+        print "Error: Need --init-checkpoint-dir and --checkpoint-dir for checkpoint mode"
+        sys.exit(1)
+elif options.simpoint_mode == "simulate" and options.checkpoint_dir == None:
+    print "Error: Need --checkpoint-dir for simulation mode."
+    sys.exit(1)
+
+if options.isolated_cpus != None:
+    isolated_cpu_list = options.isolated_cpus.split(',')
+
+    # Basic sanity check, it's up to the user to not have duplicates.
+    # Hopefully linux prints an error in that case.
+    for isolated_cpu in isolated_cpu_list:
+        if int(isolated_cpu) > options.num_cpus or int(isolated_cpu) < 0:
+            print "Tried to isolate CPU %s, but there are only %d cpus" % (isolated_cpu, options.num_cpus)
+            sys.exit(1)
+
+    # Is this an error? Let linux decide
+    if len(isolated_cpu_list) == options.num_cpus:
+        print "Warning: All CPUs are isolated!"
+
+# Parse benchmark option
+simpoint_list = []
+if options.simpoint_mode == "checkpoint" or options.simpoint_mode == "fastfwd":
+    bench_list = options.benchmark.split(':')
+    fsBench_list = []
+    simpoint_inst_list = []
+
+    for bench in bench_list:
+        specBench = spec_fs.getSPECFSBench(bench)
+        fsBench_list.append(specBench)
+        print "Benchmark %s starts at %d" % (bench, specBench.getSimpoint())
+        if not specBench.getSimpoint() in simpoint_list:
+            simpoint_list.append(specBench.getSimpoint())
+
+    sorted_points = sorted(fsBench_list, key=operator.attrgetter('simpoint'))
+    sorted_points.reverse()
+
+    max_simpoint_inst = max(simpoint_list)
+    for point in sorted_points:
+        next_inst = max_simpoint_inst - point.getSimpoint()
+        if not next_inst in simpoint_inst_list:
+            simpoint_inst_list.append(next_inst)
+        point.setStartInst(next_inst)
+
+    print "Starting benchmarks at %d inst counts:" % len(simpoint_inst_list)
+    for inst in simpoint_inst_list:
+        print inst
+
+    for point in sorted_points:
+        print "Bench %s starting at inst %d (simpoint is %d)" % (point.getCmd(), point.getStartInst(), point.getSimpoint())
+
+# Setup base machine
+bm = [SysConfig(disk=options.disk_image, mem=options.mem_size)]
+
+# At the moment simulation always begins in atomic. Simulate mode will
+# quickly switch into a timing CPU
+sim_mem_mode = "atomic"
+
+test_sys = makeLinuxX86System(sim_mem_mode, options.num_cpus, bm[0])
+
+# Add isolated CPUs option if used
+if options.isolated_cpus != None:
+    test_sys.boot_osflags = "%s isolcpus=%s" % (test_sys.boot_osflags, options.isolated_cpus)
+
+# Voltage and Clock Domains
+test_sys.voltage_domain = VoltageDomain(voltage = options.sys_voltage)
+test_sys.clk_domain = SrcClockDomain(clock =  options.sys_clock,
+                                     voltage_domain = test_sys.voltage_domain)
+test_sys.cpu_voltage_domain = VoltageDomain()
+test_sys.cpu_clk_domain = SrcClockDomain(clock = options.cpu_clock,
+                                         voltage_domain =
+                                         test_sys.cpu_voltage_domain)
+
+if options.kernel is not None:
+    test_sys.kernel = binary(options.kernel)
+
+if options.script is not None:
+    test_sys.readfile = options.script
+
+test_sys.init_param = options.init_param
+
+# Parse system config file
+config = ConfigParser.RawConfigParser()
+config.optionxform = str
+config.read(options.cfg)
+
+config.remove_option('cpu', 'type')
+
+# For now, assign all the CPUs to the same clock domain
+np = options.num_cpus
+
+test_sys.cpu = [AtomicSimpleCPU(clk_domain=test_sys.cpu_clk_domain, cpu_id=i, switched_out=False) for i in xrange(np)]
+
+for i in xrange(np):
+    test_sys.cpu[i].createThreads()
+    if options.simpoint_mode == "checkpoint" or options.simpoint_mode == "fastfwd":
+        # This is meant to get to the last simpoint. Not sure what will happen if
+        # the simpoint is instruction 0.
+        test_sys.cpu[i].max_insts_all_threads = max(simpoint_list)
+
+if options.simpoint_mode == "simulate" or options.simpoint_mode == "fastfwd":
+    cpu_options = dict(config.items('cpu'))
+    simulate_cpu = [Nehalem(clk_domain=test_sys.cpu_clk_domain, cpu_id=i, switched_out=True, **cpu_options) for i in xrange(np)]
+    for i in xrange(np):
+        simulate_cpu[i].workload = test_sys.cpu[i].workload
+        if options.max_insts:
+            #test_sys.cpu[i].max_insts_all_threads = options.max_insts
+            simulate_cpu[i].max_insts_all_threads = options.max_insts
+
+    switch_cpu_list = [(test_sys.cpu[i], simulate_cpu[i]) for i in xrange(np)]
+    test_sys.switch_cpu = simulate_cpu
+
+if options.simpoint_mode == "checkpoint" or options.simpoint_mode == "fastfwd":
+    # We need a reference CPU to see how many instructions were run.
+    ref_cpu = 0
+
+    # If we are using isolated CPUs, choose the first one as the reference
+    if options.isolated_cpus != None:
+        ref_cpu = int(options.isolated_cpus.split(',')[0])
+
+    test_sys.cpu[ref_cpu].simpoint_start_insts = simpoint_inst_list
+
+#test_sys.iobridge = Bridge(delay='50ns', ranges = test_sys.mem_ranges)
+test_sys.iocache = IOCache(addr_ranges = test_sys.mem_ranges)
+test_sys.iocache.cpu_side = test_sys.iobus.master
+test_sys.iocache.mem_side = test_sys.membus.slave
+
+# Configure L2 cache
+if config.has_section('l2') and not options.private_l2:
+    l2_options = dict(config.items('l2'))
+    if l2_options.has_key('prefetcher'):
+        l2_options['prefetcher'] = eval(l2_options['prefetcher'])
+    test_sys.l2 = BaseCache(clk_domain = test_sys.cpu_clk_domain, **l2_options)
+    test_sys.tol2bus = CoherentBus(clk_domain = test_sys.cpu_clk_domain, width = 32)
+    test_sys.l2.cpu_side = test_sys.tol2bus.master
+    if config.has_section('l3') == False:
+        test_sys.l2.mem_side = test_sys.membus.slave
+elif config.has_section('l2') and options.private_l2:
+    l2_options = dict(config.items('l2'))
+    if l2_options.has_key('prefetcher'):
+        l2_options['prefetcher'] = eval(l2_options['prefetcher'])
+    test_sys.l2 = [BaseCache(clk_domain = test_sys.cpu_clk_domain, **l2_options) for i in xrange(np)]
+    test_sys.tol2bus = [CoherentBus(clk_domain = test_sys.cpu_clk_domain, width = 32) for i in xrange(np)]
+    for idx in xrange(np):
+        test_sys.l2[idx].cpu_side = test_sys.tol2bus[idx].master
+
+# Configure L3 cache
+if config.has_section('l3'):
+    l3_options = dict(config.items('l3'))
+    if l3_options.has_key('prefetcher'):
+        l3_options['prefetcher'] = eval(l3_options['prefetcher'])
+    test_sys.l3 = BaseCache(clk_domain = test_sys.cpu_clk_domain, **l3_options)
+    test_sys.tol3bus = CoherentBus(clk_domain = test_sys.clk_domain, width = 16)
+    if not options.private_l2:
+        test_sys.l2.mem_side = test_sys.tol3bus.slave
+    else:
+        for idx in xrange(np):
+            test_sys.l2[idx].mem_side = test_sys.tol3bus.slave
+    test_sys.l3.cpu_side = test_sys.tol3bus.master
+    test_sys.l3.mem_side = test_sys.membus.slave
+
+for i in xrange(options.num_cpus):
+    icache = None
+    if config.has_section('icache') == False:
+        print "Error: no icache defined."
+        sys.exit(1)
+    icache_options = dict(config.items('icache'))
+    if icache_options.has_key('prefetcher'):
+        icache_options['prefetcher'] = eval(icache_options['prefetcher'])
+    icache = BaseCache(**icache_options)
+
+    dcache = None
+    if config.has_section('dcache') == False:
+        print "Error: no dcache defined."
+        sys.exit(1)
+    dcache_options = dict(config.items('dcache'))
+    if dcache_options.has_key('prefetcher'):
+        dcache_options['prefetcher'] = eval(dcache_options['prefetcher'])
+    dcache = BaseCache(**dcache_options)
+
+    if buildEnv['TARGET_ISA'] == 'x86':
+        test_sys.cpu[i].addPrivateSplitL1Caches(icache, dcache,
+                                              PageTableWalkerCache(),
+                                              PageTableWalkerCache())
+    else:
+        test_sys.cpu[i].addPrivateSplitL1Caches(icache, dcache)
+    test_sys.cpu[i].createInterruptController()
+
+    if config.has_section('l2'):
+        if not options.private_l2:
+            test_sys.cpu[i].connectAllPorts(test_sys.tol2bus, test_sys.membus)
+        else:
+            test_sys.cpu[i].connectAllPorts(test_sys.tol2bus[i], test_sys.membus)
+    else:
+        test_sys.cpu[i].connectAllPorts(test_sys.membus)
+
+
+MemConfig.config_mem(options, test_sys)
+
+root = Root(full_system=True, system=test_sys)
+
+checkpoint_dir = None
+if options.simpoint_mode == "checkpoint" or options.simpoint_mode == "fastfwd":
+    checkpoint_dir = os.path.join(options.init_checkpoint_dir, "cpt.init")
+elif options.simpoint_mode == "simulate" or options.simpoint_mode == "check_affinity":
+    checkpoint_dir = os.path.join(options.checkpoint_dir, "cpt.%s" % options.benchmark.replace(':', '_'))
+m5.instantiate(checkpoint_dir)
+
+term_port = test_sys.pc.com_1.terminal.getListenPort()
+
+print "**** REAL SIMULATION ****"
+
+start_count = 0
+maxtick = m5.MaxTick
+
+if options.simpoint_mode == "init":
+    (term, inpipe) = pyterm.pyterm(term_port)
+elif options.simpoint_mode == "checkpoint" or options.simpoint_mode == "fastfwd":
+    (term, inpipe) = pyterm.pyterm(term_port)
+
+    print "Waiting for bash shell to start..."
+
+    exit_event = m5.simulate(m5.curTick() + 100000000000)
+    exit_cause = exit_event.getCause()
+
+    print "Wait stopped because %s" % exit_cause
+
+    print "Starting longest simpoint benchmark(s) on CPU0"
+
+    for bench in sorted_points:
+        if bench.getStartInst() == 0:
+            start_cpu = start_count
+
+            # Start on an isolated_cpu..
+            if options.isolated_cpus != None:
+                isolated_cpu_list = options.isolated_cpus.split(',')
+                start_cpu = int(isolated_cpu_list[start_count % len(isolated_cpu_list)])
+
+            print "Starting benchmark %s on CPU %d" % (bench.getCmd(), start_cpu)
+            inpipe.send(spec_fs.getSPECCmd(bench, start_cpu))
+            inpipe.send("export PID%i=$!\n" % start_count)
+            start_count = start_count + 1
+
+    if start_count >= len(sorted_points) and options.simpoint_mode == "checkpoint":
+        print "Sending checkpoint write (deferred) -- All at 0"
+
+        stop_cmd = "kill -s SIGSTOP "
+        for pid in xrange(len(options.benchmark.split(':'))):
+            stop_cmd = "%s $PID%i" % (stop_cmd, pid)
+        #inpipe.send("%s\n" % stop_cmd)
+        inpipe.send("/sbin/m5 checkpoint 1000000\n")
+
+        exit_event = m5.simulate()
+        exit_cause = exit_event.getCause()
+
+        if exit_cause == "checkpoint":
+            mkdir_p(options.checkpoint_dir)
+            m5.checkpoint(os.path.join(options.checkpoint_dir, "cpt.%s" % options.benchmark.replace(':', '_')))
+        pyterm.close_pyterm(term, inpipe)
+
+        print 'Exiting @ tick %i because %s' % (m5.curTick(), exit_event.getCause())
+        if not m5.options.interactive:
+            sys.exit(exit_event.getCode())
+        sys.exit(0)
+    elif start_count >= len(sorted_points) and options.simpoint_mode =="fastfwd":
+        inpipe.send("/sbin/m5 switchcpus\n")
+
+        exit_event = m5.simulate()
+        exit_cause = exit_event.getCause()
+
+        if exit_cause == "switch cpus":
+            print "Done fast-forwarding -- Switching to detailed CPU"
+
+            m5.switchCpus(test_sys, switch_cpu_list)
+        else:
+            print "exit_cause was %s" % exit_cause
+            sys.exit(1)
+
+elif options.simpoint_mode == "simulate":
+    (term, inpipe) = pyterm.pyterm(term_port)
+
+    print "Waiting for bash shell to start (tick %i)..." % m5.curTick()
+
+    exit_event = m5.simulate(10000000)
+    #exit_event = m5.simulate(10000000000)
+    exit_cause = exit_event.getCause()
+
+    print "Wait stopped because %s" % exit_cause
+    print "Switching CPUS at tick %s" % m5.curTick()
+
+    # For some reason if we restore with a detailed CPU linux
+    # crashes with a bad page state error
+    m5.switchCpus(test_sys, switch_cpu_list)
+
+    cont_cmd = "kill -s SIGCONT "
+    for pid in xrange(len(options.benchmark.split(':'))):
+        cont_cmd = "%s $PID%i" % (cont_cmd, pid)
+    #inpipe.send("%s\n" % cont_cmd)
+    inpipe.send("echo Affirmative\n")
+elif options.simpoint_mode == "check_affinity":
+    (term, inpipe) = pyterm.pyterm(term_port)
+
+    print "Waiting for bash shell to start (tick %i)..." % m5.curTick()
+
+    exit_event = m5.simulate(10000000000)
+    exit_cause = exit_event.getCause()
+
+    print "Wait stopped because %s" % exit_cause
+
+    inpipe.send("mount -t proc proc /proc\n")
+    inpipe.send("ps -aF\n")
+    inpipe.send("/sbin/m5 exit\n")
+
+    exit_event = m5.simulate(m5.curTick() + 10000000000)
+    exit_cause = exit_event.getCause()
+
+    pyterm.close_pyterm(term, inpipe)
+    sys.exit(0)
+
+exit_event = m5.simulate(maxtick - m5.curTick())
+exit_cause = exit_event.getCause()
+
+if options.simpoint_mode == "init":
+    if exit_cause == "checkpoint":
+        mkdir_p(options.init_checkpoint_dir)
+        m5.checkpoint(os.path.join(options.init_checkpoint_dir, "cpt.init"))
+    pyterm.close_pyterm(term, inpipe)
+elif options.simpoint_mode == "checkpoint" or options.simpoint_mode == "fastfwd":
+    num_inst_steps = 0
+    max_inst_steps = len(simpoint_list)
+
+    while exit_cause == "simpoint starting point found":
+        m5.stats.dump()
+
+        num_inst_steps = num_inst_steps + 1
+
+        if num_inst_steps >= max_inst_steps:
+            exit_cause = "%d simpoints aligned" % len(bench_list)
+            break
+
+        cur_inst = simpoint_inst_list[num_inst_steps]
+        print "Current inst should be %d" % simpoint_list[num_inst_steps]
+
+        for bench in sorted_points:
+            if bench.getStartInst() == cur_inst:
+                start_cpu = start_count % options.num_cpus
+
+                # Start on an isolated_cpu..
+                if options.isolated_cpus != None:
+                    isolated_cpu_list = options.isolated_cpus.split(',')
+                    start_cpu = int(isolated_cpu_list[start_count % len(isolated_cpu_list)])
+
+                print "Starting benchmark %s on CPU %d" % (bench.getCmd(), start_cpu)
+                inpipe.send(spec_fs.getSPECCmd(bench, start_cpu))
+                inpipe.send("export PID%i=$!\n" % start_count)
+                start_count = start_count + 1
+
+        if start_count >= len(sorted_points):
+            # Continue until max instruction...
+
+            exit_event = m5.simulate()
+            exit_cause = exit_event.getCause()
+
+            if exit_cause != "all threads reached the max instruction count":
+                print "WARNING: Expected max instruction count exit, but the cause was: %s" % exit_cause
+                print "Continuing anyways..."
+
+            if options.simpoint_mode == "fastfwd":
+                break
+
+            print "Sending checkpoint write (deferred)"
+
+            stop_cmd = "kill -s SIGSTOP "
+            for pid in xrange(len(options.benchmark.split(':'))):
+                stop_cmd = "%s $PID%i" % (stop_cmd, pid)
+            #inpipe.send("%s\n" % stop_cmd)
+            inpipe.send("/sbin/m5 checkpoint 1000000\n")
+
+        exit_event = m5.simulate()
+        exit_cause = exit_event.getCause()
+
+        if exit_cause == "checkpoint":
+            m5.checkpoint(os.path.join(options.checkpoint_dir, "cpt.%s" % options.benchmark.replace(':', '_')))
+
+        assert exit_cause is not "simpoint starting point found"
+
+    if options.simpoint_mode == "fastfwd":
+        m5.switchCpus(test_sys, switch_cpu_list)
+
+        print "*** FAST FORWARD FINISHED ***"
+
+        exit_event = m5.simulate(maxtick - m5.curTick())
+        exit_cause = exit_event.getCause()
+
+    pyterm.close_pyterm(term, inpipe)
+elif options.simpoint_mode == "simulate":
+    pyterm.close_pyterm(term, inpipe)
+
+print 'Exiting @ tick %i because %s' % (m5.curTick(), exit_event.getCause())
+if not m5.options.interactive:
+    sys.exit(exit_event.getCode())
+
diff -r 5125a461f509 configs/spec2006/spec_fs.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/spec2006/spec_fs.py	Tue Jun 24 09:50:24 2014 -0400
@@ -0,0 +1,150 @@
+#spec_fs.py
+
+import sys
+
+class fsBench:
+    def __init__(self, cmd):
+        self.cmd = cmd
+        self.cwd = "/tmp"
+        self.simpoint = 1
+
+    def setCwd(self, cwd):
+        self.cwd = cwd
+
+    def setSimpoint(self, simpoint):
+        self.simpoint = simpoint
+
+    def setStartInst(self, inst):
+        self.start_inst = inst
+
+    def setName(self, name):
+        self.name = name
+
+    def getCmd(self):
+        return self.cmd
+
+    def getCwd(self):
+        return self.cwd
+
+    def getSimpoint(self):
+        return self.simpoint
+
+    def getStartInst(self):
+        return self.start_inst
+
+    def getName(self):
+        return self.name
+
+spec_fs_cmd = {}
+
+# Set benchmark command line
+spec_fs_cmd["perlbench"] = fsBench("/cpu2006/bin/spec.perlbench_base.x86-gcc -I/cpu2006/400.perlbench/data/all/input/splitmail.pl /cpu2006/400.perlbench/data/all/input/splitmail.pl 1600 12 26 16 4500")
+spec_fs_cmd["bzip2"] = fsBench("/cpu2006/bin/spec.bzip2_base.x86-gcc /cpu2006/401.bzip2/data/all/input/input.program 280")
+spec_fs_cmd["gcc"] = fsBench("/cpu2006/bin/spec.gcc_base.x86-gcc /cpu2006/403.gcc/data/ref/input/200.i -o gcc_403.gcc_200.s")
+spec_fs_cmd["bwaves"] = fsBench("/cpu2006/bin/spec.bwaves_base.x86-gcc /cpu2006/410.bwaves/data/ref/input/bwaves.in")
+spec_fs_cmd["gamess"] = fsBench("/cpu2006/bin/spec.gamess_base.x86-gcc < /cpu2006/416.gamess/data/ref/input/triazolium.config")
+spec_fs_cmd["mcf"] = fsBench("/cpu2006/bin/spec.mcf_base.x86-gcc /cpu2006/429.mcf/data/ref/input/inp.in")
+spec_fs_cmd["milc"] = fsBench("/cpu2006/bin/spec.milc_base.x86-gcc < /cpu2006/433.milc/data/ref/input/su3imp.in")
+spec_fs_cmd["zeusmp"] = fsBench("/cpu2006/bin/spec.zeusmp_base.x86-gcc")
+spec_fs_cmd["gromacs"] = fsBench("/cpu2006/bin/spec.gromacs_base.x86-gcc -silent -deffnm /cpu2006/435.gromacs/data/ref/input/gromacs.tpr -name 0")
+spec_fs_cmd["cactusADM"] = fsBench("/cpu2006/bin/spec.cactusADM_base.x86-gcc /cpu2006/436.cactusADM/data/ref/input/benchADM.par")
+spec_fs_cmd["leslie3d"] = fsBench("cpu2006/bin/spec.leslie3d_base.x86-gcc < /cpu2006/437.leslie3d/data/ref/input/leslie3d.in")
+spec_fs_cmd["namd"] = fsBench("/cpu2006/bin/spec.namd_base.x86-gcc --input /cpu2006/444.namd/data/all/input/namd.input --iterations 38 --output namd.out")
+spec_fs_cmd["gobmk"] = fsBench("/cpu2006/bin/spec.gobmk_base.x86-gcc --quiet --mode gtp < /cpu2006/445.gobmk/data/ref/input/nngs.tst")
+spec_fs_cmd["dealII"] = fsBench("/cpu2006/bin/spec.dealII_base.x86-gcc 23")
+spec_fs_cmd["soplex"] = fsBench("/cpu2006/bin/spec.soplex_base.x86-gcc -m3500 /cpu2006/450.soplex/data/ref/input/ref.mps")
+spec_fs_cmd["povray"] = fsBench("/cpu2006/bin/spec.povray_base.x86-gcc /cpu2006/453.povray/data/all/input/SPEC-benchmark-ref.ini")
+spec_fs_cmd["calculix"] = fsBench("/cpu2006/bin/spec.calculix_base.x86-gcc -i /cpu2006/454.calculix/data/ref/input/hyperviscoplastic")
+spec_fs_cmd["hmmer"] = fsBench("/cpu2006/bin/spec.hmmer_base.x86-gcc --fixed 0 --mean 500 --num 500000 --sd 350 --seed 0 /cpu2006/456.hmmer/data/ref/input/retro.hmm")
+spec_fs_cmd["sjeng"] = fsBench("/cpu2006/bin/spec.sjeng_base.x86-gcc /cpu2006/458.sjeng/data/ref/input/ref.txt")
+spec_fs_cmd["GemsFDTD"] = fsBench("/cpu2006/bin/spec.GemsFDTD_base.x86-gcc")
+spec_fs_cmd["libquantum"] = fsBench("/cpu2006/bin/spec.libquantum_base.x86-gcc 1397 8")
+spec_fs_cmd["h264ref"] = fsBench("/cpu2006/bin/spec.h264ref_base.x86-gcc -d /cpu2006/464.h264ref/data/ref/input/foreman_ref_encoder_baseline.cfg")
+spec_fs_cmd["tonto"] = fsBench("/cpu2006/bin/spec.tonto_base.x86-gcc")
+spec_fs_cmd["lbm"] = fsBench("/cpu2006/bin/spec.lbm_base.x86-gcc 3000 reference.dat 0 0 /cpu2006/470.lbm/data/ref/input/100_100_130_ldc.of")
+spec_fs_cmd["omnetpp"] = fsBench("/cpu2006/bin/spec.omnetpp_base.x86-gcc /cpu2006/471.omnetpp/data/ref/input/omnetpp.ini")
+spec_fs_cmd["astar"] = fsBench("/cpu2006/bin/spec.astar_base.x86-gcc /cpu2006/473.astar/data/ref/input/BigLakes2048.cfg")
+spec_fs_cmd["wrf"] = fsBench("/cpu2006/bin/spec.wrf_base.x86-gcc /cpu2006/481.wrf/data/ref/input/namelist.input")
+spec_fs_cmd["sphinx"] = fsBench("/cpu2006/bin/spec.sphinx_livepretend_base.x86-gcc /cpu2006/482.sphinx3/data/all/input/model/lm/an4/an4.ctl . /cpu2006/482.sphinx3/data/all/input/args.an4")
+spec_fs_cmd["xalancbmk"] = fsBench("/cpu2006/bin/spec.Xalan_base.x86-gcc -v /cpu2006/483.xalancbmk/data/ref/input/t5.xml /cpu2006/483.xalancbmk/data/ref/input/xalanc.xsl")
+spec_fs_cmd["specrand_i"] = fsBench("/cpu2006/bin/spec.specrand_base.x86-gcc 324342 24239")
+spec_fs_cmd["specrand_f"] = fsBench("/cpu2006/bin/spec.specrand_base.x86-gcc 324342 24239")
+
+#
+# Benchmarks to test pyterm -- These program output test at the beginning
+#
+
+# test1 -- hmmer
+spec_fs_cmd["test1"] = fsBench("/cpu2006/bin/spec.hmmer_base.x86-gcc --fixed 0 --mean 500 --num 500000 --sd 350 --seed 0 /cpu2006/456.hmmer/data/ref/input/retro.hmm")
+# test2 -- gobmk
+spec_fs_cmd["test2"] = fsBench("/cpu2006/bin/spec.gobmk_base.x86-gcc --mode gtp < /cpu2006/445.gobmk/data/ref/input/nngs.tst")
+# test3 -- mcf
+spec_fs_cmd["test3"] = fsBench("/cpu2006/bin/spec.mcf_base.x86-gcc /cpu2006/429.mcf/data/ref/input/inp.in")
+# test4 -- libquantum
+spec_fs_cmd["test4"] = fsBench("/cpu2006/bin/spec.libquantum_base.x86-gcc 1397 8")
+
+# Set the benchmark's working directory
+spec_fs_cmd["bwaves"].setCwd("/cpu2006/410.bwaves/data/ref/input")
+spec_fs_cmd["gamess"].setCwd("/cpu2006/416.gamess/data/ref/input")
+spec_fs_cmd["zeusmp"].setCwd("/cpu2006/434.zeusmp/data/ref/input")
+spec_fs_cmd["gobmk"].setCwd("/cpu2006/445.gobmk/data/all/input")
+spec_fs_cmd["povray"].setCwd("/cpu2006/453.povray/data/all/input")
+spec_fs_cmd["GemsFDTD"].setCwd("/cpu2006/459.GemsFDTD/data/ref/input")
+spec_fs_cmd["h264ref"].setCwd("/cpu2006/464.h264ref/data/all/input")
+spec_fs_cmd["tonto"].setCwd("/cpu2006/465.tonto/data/ref/input")
+spec_fs_cmd["omnetpp"].setCwd("/cpu2006/471.omnetpp/data/ref/input")
+spec_fs_cmd["astar"].setCwd("/cpu2006/473.astar/data/ref/input")
+spec_fs_cmd["wrf"].setCwd("/cpu2006/481.wrf/data/all/input")
+spec_fs_cmd["sphinx"].setCwd("/cpu2006/482.sphinx3/data/all/input")
+
+spec_fs_cmd["test2"].setCwd("/cpu2006/445.gobmk/data/all/input")
+
+# Set simpoint start
+spec_fs_cmd["astar"].setSimpoint(5600000000)
+spec_fs_cmd["bwaves"].setSimpoint(7800000000)
+spec_fs_cmd["GemsFDTD"].setSimpoint(200000000)
+spec_fs_cmd["gobmk"].setSimpoint(0)
+spec_fs_cmd["lbm"].setSimpoint(3000000000)
+spec_fs_cmd["leslie3d"].setSimpoint(6000000000)
+spec_fs_cmd["libquantum"].setSimpoint(9400000000)
+spec_fs_cmd["mcf"].setSimpoint(3400000000)
+spec_fs_cmd["milc"].setSimpoint(7800000000)
+spec_fs_cmd["soplex"].setSimpoint(6600000000)
+spec_fs_cmd["zeusmp"].setSimpoint(6400000000)
+
+# Low memory usage benchmarks
+spec_fs_cmd["bzip2"].setSimpoint(4000000000)
+spec_fs_cmd["cactusADM"].setSimpoint(6600000000)
+spec_fs_cmd["gamess"].setSimpoint(4200000000)
+spec_fs_cmd["gcc"].setSimpoint(600000000)
+spec_fs_cmd["gromacs"].setSimpoint(3000000000)
+spec_fs_cmd["h264ref"].setSimpoint(5400000000)
+spec_fs_cmd["hmmer"].setSimpoint(4200000000)
+spec_fs_cmd["namd"].setSimpoint(7400000000)
+spec_fs_cmd["omnetpp"].setSimpoint(9200000000)
+spec_fs_cmd["povray"].setSimpoint(4000000000)
+spec_fs_cmd["sjeng"].setSimpoint(1400000000)
+spec_fs_cmd["sphinx"].setSimpoint(0)
+spec_fs_cmd["tonto"].setSimpoint(600000000)
+
+# Tests -- start in a short time for testing
+spec_fs_cmd["test1"].setSimpoint(30000000)
+spec_fs_cmd["test2"].setSimpoint(20000000)
+spec_fs_cmd["test3"].setSimpoint(10000000)
+spec_fs_cmd["test4"].setSimpoint(40000000)
+
+
+def getSPECFSBench(bench):
+    if not bench in spec_fs_cmd:
+        print "Benchmark %s not found!" % bench
+        sys.exit(1)
+
+    spec_fs_cmd[bench].setName(bench)
+
+    return spec_fs_cmd[bench]
+
+
+def getSPECCmd(bench, cpu):
+    return "cd %s; taskset -c %d %s &\n" % (bench.cwd, cpu, bench.cmd)
+
+
diff -r 5125a461f509 configs/spec2006/spec_fs.rcS
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/spec2006/spec_fs.rcS	Tue Jun 24 09:50:24 2014 -0400
@@ -0,0 +1,2 @@
+/sbin/m5 checkpoint
+/bin/bash
diff -r 5125a461f509 configs/spec2006/spec_fs_matt.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/spec2006/spec_fs_matt.py	Tue Jun 24 09:50:24 2014 -0400
@@ -0,0 +1,150 @@
+#spec_fs.py
+
+import sys
+
+class fsBench:
+    def __init__(self, cmd):
+        self.cmd = cmd
+        self.cwd = "/tmp"
+        self.simpoint = 1
+
+    def setCwd(self, cwd):
+        self.cwd = cwd
+
+    def setSimpoint(self, simpoint):
+        self.simpoint = simpoint
+
+    def setStartInst(self, inst):
+        self.start_inst = inst
+
+    def setName(self, name):
+        self.name = name
+
+    def getCmd(self):
+        return self.cmd
+
+    def getCwd(self):
+        return self.cwd
+
+    def getSimpoint(self):
+        return self.simpoint
+
+    def getStartInst(self):
+        return self.start_inst
+
+    def getName(self):
+        return self.name
+
+spec_fs_cmd = {}
+
+# Set benchmark command line
+spec_fs_cmd["perlbench"] = fsBench("/cpu2006/bin/400.perlbench_base.x86-gcc -I/cpu2006/400.perlbench/data/all/input/splitmail.pl /cpu2006/400.perlbench/data/all/input/splitmail.pl 1600 12 26 16 4500")
+spec_fs_cmd["bzip2"] = fsBench("/cpu2006/bin/401.bzip2_base.x86-gcc /cpu2006/401.bzip2/data/all/input/input.program 280")
+spec_fs_cmd["gcc"] = fsBench("/cpu2006/bin/403.gcc_base.x86-gcc /cpu2006/403.gcc/data/ref/input/200.i -o gcc_403.gcc_200.s")
+spec_fs_cmd["bwaves"] = fsBench("/cpu2006/bin/410.bwaves_base.x86-gcc /cpu2006/410.bwaves/data/ref/input/bwaves.in")
+spec_fs_cmd["gamess"] = fsBench("/cpu2006/bin/416.gamess_base.x86-gcc < /cpu2006/416.gamess/data/ref/input/triazolium.config")
+spec_fs_cmd["mcf"] = fsBench("/cpu2006/bin/429.mcf_base.x86-gcc /cpu2006/429.mcf/data/ref/input/inp.in")
+spec_fs_cmd["milc"] = fsBench("/cpu2006/bin/433.milc_base.x86-gcc < /cpu2006/433.milc/data/ref/input/su3imp.in")
+spec_fs_cmd["zeusmp"] = fsBench("/cpu2006/bin/434.zeusmp_base.x86-gcc")
+spec_fs_cmd["gromacs"] = fsBench("/cpu2006/bin/435.gromacs_base.x86-gcc -silent -deffnm /cpu2006/435.gromacs/data/ref/input/gromacs.tpr -name 0")
+spec_fs_cmd["cactusADM"] = fsBench("/cpu2006/bin/436.cactusADM_base.x86-gcc /cpu2006/436.cactusADM/data/ref/input/benchADM.par")
+spec_fs_cmd["leslie3d"] = fsBench("cpu2006/bin/437.leslie3d_base.x86-gcc < /cpu2006/437.leslie3d/data/ref/input/leslie3d.in")
+spec_fs_cmd["namd"] = fsBench("/cpu2006/bin/444.namd_base.x86-gcc --input /cpu2006/444.namd/data/all/input/namd.input --iterations 38 --output namd.out")
+spec_fs_cmd["gobmk"] = fsBench("/cpu2006/bin/445.gobmk_base.x86-gcc --quiet --mode gtp < /cpu2006/445.gobmk/data/ref/input/nngs.tst")
+spec_fs_cmd["dealII"] = fsBench("/cpu2006/bin/447.dealII_base.x86-gcc 23")
+spec_fs_cmd["soplex"] = fsBench("/cpu2006/bin/450.soplex_base.x86-gcc -m3500 /cpu2006/450.soplex/data/ref/input/ref.mps")
+spec_fs_cmd["povray"] = fsBench("/cpu2006/bin/453.povray_base.x86-gcc /cpu2006/453.povray/data/all/input/SPEC-benchmark-ref.ini")
+spec_fs_cmd["calculix"] = fsBench("/cpu2006/bin/454.calculix_base.x86-gcc -i /cpu2006/454.calculix/data/ref/input/hyperviscoplastic")
+spec_fs_cmd["hmmer"] = fsBench("/cpu2006/bin/456.hmmer_base.x86-gcc --fixed 0 --mean 500 --num 500000 --sd 350 --seed 0 /cpu2006/456.hmmer/data/ref/input/retro.hmm")
+spec_fs_cmd["sjeng"] = fsBench("/cpu2006/bin/458.sjeng_base.x86-gcc /cpu2006/458.sjeng/data/ref/input/ref.txt")
+spec_fs_cmd["GemsFDTD"] = fsBench("/cpu2006/bin/459.GemsFDTD_base.x86-gcc")
+spec_fs_cmd["libquantum"] = fsBench("/cpu2006/bin/462.libquantum_base.x86-gcc 1397 8")
+spec_fs_cmd["h264ref"] = fsBench("/cpu2006/bin/464.h264ref_base.x86-gcc -d /cpu2006/464.h264ref/data/ref/input/foreman_ref_encoder_baseline.cfg")
+spec_fs_cmd["tonto"] = fsBench("/cpu2006/bin/465.tonto_base.x86-gcc")
+spec_fs_cmd["lbm"] = fsBench("/cpu2006/bin/470.lbm_base.x86-gcc 3000 reference.dat 0 0 /cpu2006/470.lbm/data/ref/input/100_100_130_ldc.of")
+spec_fs_cmd["omnetpp"] = fsBench("/cpu2006/bin/471.omnetpp_base.x86-gcc /cpu2006/471.omnetpp/data/ref/input/omnetpp.ini")
+spec_fs_cmd["astar"] = fsBench("/cpu2006/bin/473.astar_base.x86-gcc /cpu2006/473.astar/data/ref/input/BigLakes2048.cfg")
+spec_fs_cmd["wrf"] = fsBench("/cpu2006/bin/481.wrf_base.x86-gcc /cpu2006/481.wrf/data/ref/input/namelist.input")
+spec_fs_cmd["sphinx"] = fsBench("/cpu2006/bin/482.sphinx_livepretend_base.x86-gcc /cpu2006/482.sphinx3/data/all/input/model/lm/an4/an4.ctl . /cpu2006/482.sphinx3/data/all/input/args.an4")
+spec_fs_cmd["xalancbmk"] = fsBench("/cpu2006/bin/483.Xalan_base.x86-gcc -v /cpu2006/483.xalancbmk/data/ref/input/t5.xml /cpu2006/483.xalancbmk/data/ref/input/xalanc.xsl")
+spec_fs_cmd["specrand_i"] = fsBench("/cpu2006/bin/998.specrand_base.x86-gcc 324342 24239")
+spec_fs_cmd["specrand_f"] = fsBench("/cpu2006/bin/999.specrand_base.x86-gcc 324342 24239")
+
+#
+# Benchmarks to test pyterm -- These program output test at the beginning
+#
+
+# test1 -- hmmer
+spec_fs_cmd["test1"] = fsBench("/cpu2006/bin/456.hmmer_base.x86-gcc --fixed 0 --mean 500 --num 500000 --sd 350 --seed 0 /cpu2006/456.hmmer/data/ref/input/retro.hmm")
+# test2 -- gobmk
+spec_fs_cmd["test2"] = fsBench("/cpu2006/bin/445.gobmk_base.x86-gcc --mode gtp < /cpu2006/445.gobmk/data/ref/input/nngs.tst")
+# test3 -- mcf
+spec_fs_cmd["test3"] = fsBench("/cpu2006/bin/429.mcf_base.x86-gcc /cpu2006/429.mcf/data/ref/input/inp.in")
+# test4 -- libquantum
+spec_fs_cmd["test4"] = fsBench("/cpu2006/bin/462.libquantum_base.x86-gcc 1397 8")
+
+# Set the benchmark's working directory
+spec_fs_cmd["bwaves"].setCwd("/cpu2006/410.bwaves/data/ref/input")
+spec_fs_cmd["gamess"].setCwd("/cpu2006/416.gamess/data/ref/input")
+spec_fs_cmd["zeusmp"].setCwd("/cpu2006/434.zeusmp/data/ref/input")
+spec_fs_cmd["gobmk"].setCwd("/cpu2006/445.gobmk/data/all/input")
+spec_fs_cmd["povray"].setCwd("/cpu2006/453.povray/data/all/input")
+spec_fs_cmd["GemsFDTD"].setCwd("/cpu2006/459.GemsFDTD/data/ref/input")
+spec_fs_cmd["h264ref"].setCwd("/cpu2006/464.h264ref/data/all/input")
+spec_fs_cmd["tonto"].setCwd("/cpu2006/465.tonto/data/ref/input")
+spec_fs_cmd["omnetpp"].setCwd("/cpu2006/471.omnetpp/data/ref/input")
+spec_fs_cmd["astar"].setCwd("/cpu2006/473.astar/data/ref/input")
+spec_fs_cmd["wrf"].setCwd("/cpu2006/481.wrf/data/all/input")
+spec_fs_cmd["sphinx"].setCwd("/cpu2006/482.sphinx3/data/all/input")
+
+spec_fs_cmd["test2"].setCwd("/cpu2006/445.gobmk/data/all/input")
+
+# Set simpoint start
+spec_fs_cmd["astar"].setSimpoint(5600000000)
+spec_fs_cmd["bwaves"].setSimpoint(7800000000)
+spec_fs_cmd["GemsFDTD"].setSimpoint(200000000)
+spec_fs_cmd["gobmk"].setSimpoint(0)
+spec_fs_cmd["lbm"].setSimpoint(3000000000)
+spec_fs_cmd["leslie3d"].setSimpoint(6000000000)
+spec_fs_cmd["libquantum"].setSimpoint(9400000000)
+spec_fs_cmd["mcf"].setSimpoint(3400000000)
+spec_fs_cmd["milc"].setSimpoint(7800000000)
+spec_fs_cmd["soplex"].setSimpoint(6600000000)
+spec_fs_cmd["zeusmp"].setSimpoint(6400000000)
+
+# Low memory usage benchmarks
+spec_fs_cmd["bzip2"].setSimpoint(4000000000)
+spec_fs_cmd["cactusADM"].setSimpoint(6600000000)
+spec_fs_cmd["gamess"].setSimpoint(4200000000)
+spec_fs_cmd["gcc"].setSimpoint(600000000)
+spec_fs_cmd["gromacs"].setSimpoint(3000000000)
+spec_fs_cmd["h264ref"].setSimpoint(5400000000)
+spec_fs_cmd["hmmer"].setSimpoint(4200000000)
+spec_fs_cmd["namd"].setSimpoint(7400000000)
+spec_fs_cmd["omnetpp"].setSimpoint(9200000000)
+spec_fs_cmd["povray"].setSimpoint(4000000000)
+spec_fs_cmd["sjeng"].setSimpoint(1400000000)
+spec_fs_cmd["sphinx"].setSimpoint(0)
+spec_fs_cmd["tonto"].setSimpoint(600000000)
+
+# Tests -- start in a short time for testing
+spec_fs_cmd["test1"].setSimpoint(30000000)
+spec_fs_cmd["test2"].setSimpoint(20000000)
+spec_fs_cmd["test3"].setSimpoint(10000000)
+spec_fs_cmd["test4"].setSimpoint(40000000)
+
+
+def getSPECFSBench(bench):
+    if not bench in spec_fs_cmd:
+        print "Benchmark %s not found!" % bench
+        sys.exit(1)
+
+    spec_fs_cmd[bench].setName(bench)
+
+    return spec_fs_cmd[bench]
+
+
+def getSPECCmd(bench, cpu):
+    return "cd %s; taskset -c %d %s &\n" % (bench.cwd, cpu, bench.cmd)
+
+
diff -r 5125a461f509 src/dev/Terminal.py
--- a/src/dev/Terminal.py	Tue Jun 24 08:37:03 2014 -0400
+++ b/src/dev/Terminal.py	Tue Jun 24 09:50:24 2014 -0400
@@ -33,6 +33,17 @@
 class Terminal(SimObject):
     type = 'Terminal'
     cxx_header = "dev/terminal.hh"
+
+    @classmethod
+    def export_method_cxx_predecls(cls, code):
+        code('#include "dev/terminal.hh"')
+
+    @classmethod
+    def export_methods(cls, code):
+        code('''
+      int getListenPort() const;
+''')
+
     intr_control = Param.IntrControl(Parent.any, "interrupt controller")
     port = Param.TcpPort(3456, "listen port")
     number = Param.Int(0, "terminal number")
diff -r 5125a461f509 src/dev/terminal.cc
--- a/src/dev/terminal.cc	Tue Jun 24 08:37:03 2014 -0400
+++ b/src/dev/terminal.cc	Tue Jun 24 09:50:24 2014 -0400
@@ -154,6 +154,8 @@
     ccprintf(cerr, "Listening for %s connection on port %d\n",
             name().substr(p1+1,p2-p1), port);
 
+    listen_port = port;
+
     listenEvent = new ListenEvent(this, listener.getfd(), POLLIN);
     pollQueue.schedule(listenEvent);
 }
diff -r 5125a461f509 src/dev/terminal.hh
--- a/src/dev/terminal.hh	Tue Jun 24 08:37:03 2014 -0400
+++ b/src/dev/terminal.hh	Tue Jun 24 09:50:24 2014 -0400
@@ -89,6 +89,8 @@
     Terminal(const Params *p);
     ~Terminal();
 
+    int getListenPort() const { return listen_port; }
+
   protected:
     ListenSocket listener;
 
@@ -102,6 +104,7 @@
 #if TRACING_ON == 1
     CircleBuf linebuf;
 #endif
+    int listen_port;
 
   public:
     ///////////////////////
